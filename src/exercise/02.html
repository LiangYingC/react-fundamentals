<!-- Intro to raw React APIs -->
<!-- http://localhost:3000/isolated/exercise/02.html -->

<body>
  <div id="root"></div>

  <!-- unpkg: https://unpkg.com/Ôºålike import React -->
  <script src="https://unpkg.com/react@16.13.1/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@16.13.1/umd/react-dom.development.js"></script>

  <script type="module">
    const rootElement = document.getElementById('root')
    const e = React.createElement

    const helloElement = e('span', {key: 1}, 'Hello')
    const worldElement = e('span', {key: 2}, 'World !')
    const containerElement = e('div', {
      className: 'container',
      children: [helloElement, ' ', worldElement],
    })

    ReactDOM.render(containerElement, rootElement)

    /*
      if console.log(containerElement)
      will get something like : 
      {
        $$typeof: Symbol(react.element),
        key: null,
        props: {
          children: [
            0: { $$typeof: Symbol(react.element), type: "span", key: "1", ref: null, props: { ‚Ä¶ }, ‚Ä¶ }
            1: " "
            2: { $$typeof: Symbol(react.element), type: "span", key: "2", ref: null, props: { ‚Ä¶ }, ‚Ä¶ }
          ],
          className: "container"
        },
        ref: null,
        type: "div"
        ...
      } 

      When you pass an object like that to ReactDOM.render or any other renderer, 
      it's the renderer's job to interpret that element object and create DOM nodes or whatever else out of it.

      Reference : https://kentcdodds.com/blog/what-is-jsx
    */

    /* 
      // These three lines are similar to React.createElement
      // const element = document.createElement('div')
      // element.textContent = 'Hello World' // üí∞ in React, you set this with the "children" prop
      // element.className = 'container' // üí∞ in React, this is also called the "className" prop
      // React.createElement( type, [props], [...children])

      // rootElement.append(element) is similar to ReactDOM.render
      // ReactDOM.render(element, container[, callback])
    */
  </script>

  <!-- Good To Read : https://ui.dev/imperative-vs-declarative-programming/-->
  <!-- Note -->
  <ul>
    <li>
      Imperative programming is like <strong>how</strong> you do something, and
      declarative programming is more like <strong>what</strong> you do.
    </li>
    <li>
      Many (if not all)
      <strong
        >declarative approaches have some sort of underlying imperative
        abstraction</strong
      >.
    </li>
    <li>
      Declarative programming is ‚Äúthe act of programming in languages that
      conform to the mental model of the developer rather than the operational
      model of the machine.‚Äù
    </li>
    <li>
      <p>Declarative</p>
      <pre>
        function double (arr) { 
          let results = [] 
          for (let i = 0; i < arr.length;i++)
          { 
            results.push(arr[i] * 2) 
          } 
          return results 
        }

        function add (arr) {
          let result = 0
          for (let i = 0; i < arr.length; i++){
            result += arr[i]
          }
          return result
        }
      </pre>
    </li>
    <li>
      <p>Imperative</p>
      <pre>
        function double (arr) {
          return arr.map((item) => item * 2)
        }

        function add (arr) {
          return arr.reduce((prev, current) => prev + current, 0)
        }
      </pre>
    </li>
    <li>
      React abstracts away the imperative browser API from you to give you a
      <strong>much more declarative API</strong> to work with.
    </li>
    <li>
      React: responsible for creating React elements (kinda like
      document.createElement())
    </li>
    <li>
      ReactDOM: responsible for rendering React elements to the DOM (kinda like
      rootElement.append())
    </li>
  </ul>
</body>
